//
//  DataProvider.swift
//  Feature Tracker
//
//  Created by Andrew Forget on 2024-03-05.
//

import Combine
import CoreData
import SwiftData
import SwiftDataKit
import SwiftUI

@ModelActor
public actor DBMonitor {
    private var cancellable: AnyCancellable?
    // last history transaction timestamp
    private var lastHistoryTransactionTimestamp: Date {
        get {
            UserDefaults.standard.object(forKey: "lastHistoryTransactionTimestamp") as? Date ?? Date.distantPast
        }
        set {
            UserDefaults.standard.setValue(newValue, forKey: "lastHistoryTransactionTimestamp")
        }
    }
}

extension DBMonitor {
    // Respond to persistent history tracking notifications
    public func register(excludeAuthors: [String] = []) {
        guard let coordinator = modelContext.coordinator else { return }
        cancellable = NotificationCenter.default.publisher(
            for: .NSPersistentStoreRemoteChange,
            object: coordinator
        )
        .map { _ in () }
        .prepend(())
        .sink { _ in
            self.processor(excludeAuthors: excludeAuthors)
        }
    }
    
    // After receiving the notification, process the transaction
    private func processor(excludeAuthors: [String]) {
        // Get all transactions
        let transactions = fetchTransaction()
        // Save the timestamp of the latest transaction
        lastHistoryTransactionTimestamp = transactions.max { $1.timestamp > $0.timestamp }?.timestamp ?? .now
        // Filter transactions to exclude transactions generated by excludeAuthors
        for transaction in transactions where !excludeAuthors.contains([transaction.author ?? ""]) {
            for change in transaction.changes ?? [] {
                // Send transaction to processing unit
                changeHandler(change)
            }
        }
    }
    
    // Fetch all newly generated transactions since the last processing
    private func fetchTransaction() -> [NSPersistentHistoryTransaction] {
        let timestamp = lastHistoryTransactionTimestamp
        let fetchRequest = NSPersistentHistoryChangeRequest.fetchHistory(after: timestamp)
        // In SwiftData, the fetchRequest.fetchRequest created by fetchHistory is nil and predicate cannot be set.
        guard let historyResult = try? modelContext.managedObjectContext?.execute(fetchRequest) as? NSPersistentHistoryResult,
              let transactions = historyResult.result as? [NSPersistentHistoryTransaction]
        else {
            return []
        }
        return transactions
    }
    
    // Process filtered transactions
    private func changeHandler(_ change: NSPersistentHistoryChange) {
        // Convert NSManagedObjectID to PersistentIdentifier via SwiftDataKit
        //if let id = change.changedObjectID.persistentIdentifier {
            //let author = change.transaction?.author ?? "unknown"
            let changeType = change.changeType
            var changeTypeString = ""
            switch (changeType) {
            case .update:
                changeTypeString = "Update"
                break;
            case .insert:
                changeTypeString = "Insert"
                break;
            case .delete:
                changeTypeString = "Delete"
                break;
            default:
                changeTypeString = "unknown"
                break;
            }
            //print("author:\(author)")
            print("changeType:\(changeType) [\(changeTypeString)]")
            //print(id)
        //}
    }
}

public final class DataProvider: @unchecked Sendable {
    public var container: ModelContainer
    private var monitor: DBMonitor?
    
    public static let share = DataProvider(
        inMemory: false,
        enableCloudKit: CloudKitConfiguration.Enabled,
        enableMonitor: CloudKitConfiguration.AutoSync)
    public static let preview = DataProvider(inMemory: true)
    
    init(inMemory: Bool = false, enableCloudKit: Bool = false, enableMonitor: Bool = false) {
        let schema = Schema([
            Page.self,
            Feature.self,
        ])
        let modelConfiguration: ModelConfiguration
        modelConfiguration = ModelConfiguration(
            schema: schema,
            isStoredInMemoryOnly: inMemory,
            cloudKitDatabase: enableCloudKit ? .automatic : .none)
        do {
            let container = try ModelContainer(
                for: schema,
                migrationPlan: FeatureTrackerSchemaMigrationPlan.self,
                configurations: [modelConfiguration])
            self.container = container
            // Set transactionAuthor of mainContext to mainApp
            Task {
                await setAuthor(container: container, authorName: "mainApp")
            }
            // Create DBMonitor to handle persistent historical tracking transactions
            if enableMonitor {
                Task.detached {
                    self.monitor = DBMonitor(modelContainer: container)
                    await self.monitor?.register(excludeAuthors: [])
                }
            }
        } catch {
            fatalError("Could not create ModelContainer: \(error)")
        }
    }
    
    @MainActor
    private func setAuthor(container: ModelContainer, authorName: String) {
        container.mainContext.managedObjectContext?.transactionAuthor = authorName
    }
}
